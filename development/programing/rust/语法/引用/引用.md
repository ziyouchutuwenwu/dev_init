# 引用

## 场景

- 函数的参数，默认值传递，调用以后就会丢失所有权，外部访问就会出错，因此需要引用代替值作为参数。

- 避免拷贝开销

## 注意

- 简单变量二次赋值以后，第一次赋值的还能用，因为直接 copy 了

- mut 类型的引用，引用的变量也必须是 mut 类型的，否则会导致在意外修改不应该修改的数据

- 复杂变量二次赋值以后，所有权转移到新变量上面，旧变量不能使用

- 不可变引用可以同时存在多个

- 在同一作用域，只能有一个可变引用，不能和不可变同时存在，因为会导致数据冲突

## 例子

```rust
fn main() {
    let x = 5;
    let y = &x;
    let z = &x;

    println!("{} {} {}", x, *y, *z);
}
```

```rust
fn main() {
    let mut x=5;
    let z = &mut x;
    *z = 111;
    println!("{}", *z);
}
```

```rust
fn demo(x: &i32){
    println!("in demo {}", x);
}

fn main() {
    let x=5;
    demo(&x);
}
```
